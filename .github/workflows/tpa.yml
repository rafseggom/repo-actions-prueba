name: Team Project Automation (Projects v2)

# Este workflow funciona con GitHub Projects v2
on:
  issues:
    types: [opened, edited, labeled, unlabeled]
  pull_request:
    types: [opened, closed]
  # Permite ejecutar manualmente para pruebas
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to process'
        required: true
      action:
        description: 'Action to perform (branch_creation, pr_creation)'
        required: true

env:
  # Configuración de tu proyecto
  PROJECT_OWNER_TYPE: "users" 
  PROJECT_OWNER: "rafseggom"
  PROJECT_NUMBER: 2
  STATUS_FIELD_NAME: "Status"
  TODO_STATUS: "Todo"
  IN_PROGRESS_STATUS: "In Progress"
  IN_REVIEW_STATUS: "In Review"
  DONE_STATUS: "Done"
  BASE_BRANCH: "develop"  # Rama base actualizada a 'develop'

jobs:
  process_project_item:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.PAT_TOKEN }}

      - name: Get issue status from event
        id: issue_data
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.PAT_TOKEN }}
          result-encoding: string
          script: |
            let issueNumber;
            let processType;
            
            // Determinar qué tipo de evento y obtener el número de issue
            if (context.eventName === 'workflow_dispatch') {
              // Evento manual
              issueNumber = context.payload.inputs.issue_number;
              processType = context.payload.inputs.action;
              console.log(`Manual trigger for issue #${issueNumber}, action: ${processType}`);
            } 
            else if (context.eventName === 'issues') {
              // Evento de issue
              issueNumber = context.payload.issue.number;
              processType = 'check_status';
              console.log(`Issue event for #${issueNumber}`);
            }
            else if (context.eventName === 'pull_request') {
              // Evento de PR
              const prBody = context.payload.pull_request.body || '';
              const matches = prBody.match(/[Rr]esolves #(\d+)/);
              if (matches) {
                issueNumber = matches[1];
                processType = context.payload.pull_request.merged ? 'pr_merged' : 'pr_opened';
                console.log(`PR event for issue #${issueNumber}, merged: ${context.payload.pull_request.merged}`);
              } else {
                console.log('No linked issue found in PR body');
                return JSON.stringify({issue: null, process: null});
              }
            }
            
            if (issueNumber) {
              try {
                // Obtener los detalles de la issue
                const { data: issue } = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parseInt(issueNumber)
                });
                
                console.log(`Issue title: ${issue.title}`);
                
                return JSON.stringify({
                  issue: {
                    number: issueNumber,
                    title: issue.title,
                    labels: issue.labels.map(l => l.name)
                  },
                  process: processType
                });
              } catch (error) {
                console.error(`Error getting issue #${issueNumber}: ${error.message}`);
                return JSON.stringify({issue: null, process: null});
              }
            }
            
            return JSON.stringify({issue: null, process: null});

      - name: Get issue status in project
        if: ${{ fromJson(steps.issue_data.outputs.result).issue }}
        id: project_status
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.PAT_TOKEN }}
          result-encoding: string
          script: |
            const issueData = JSON.parse(process.env.ISSUE_DATA);
            const issue = issueData.issue;
            if (!issue) return JSON.stringify({status: null});
            
            const ownerType = process.env.PROJECT_OWNER_TYPE;
            const owner = process.env.PROJECT_OWNER;
            const projectNumber = parseInt(process.env.PROJECT_NUMBER);
            const statusFieldName = process.env.STATUS_FIELD_NAME;
            
            // Consulta para obtener el ID del proyecto y los campos
            const projectQuery = `
            query($owner: String!, $projectNumber: Int!) {
              ${ownerType === 'users' ? 'user(login: $owner)' : 'organization(login: $owner)'} {
                projectV2(number: $projectNumber) {
                  id
                  fields(first: 20) {
                    nodes {
                      ... on ProjectV2Field {
                        id
                        name
                      }
                      ... on ProjectV2SingleSelectField {
                        id
                        name
                        options {
                          id
                          name
                        }
                      }
                    }
                  }
                }
              }
            }`;
            
            try {
              // Obtener el proyecto y sus campos
              const projectData = await github.graphql(projectQuery, {
                owner: owner,
                projectNumber: projectNumber
              });
              
              const projectPath = ownerType === 'users' ? projectData.user.projectV2 : projectData.organization.projectV2;
              const projectId = projectPath.id;
              
              // Encontrar el campo de estado y sus opciones
              const statusField = projectPath.fields.nodes.find(field => field.name === statusFieldName);
              if (!statusField) {
                console.log(`Status field "${statusFieldName}" not found in project`);
                return JSON.stringify({status: null, projectId: projectId});
              }
              
              // Consulta para encontrar el item de la issue en el proyecto
              const itemQuery = `
              query($projectId: ID!, $issueNumber: Int!, $owner: String!, $repo: String!) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    items(first: 1, filter: {filterBy: {field: CONTENT, operator: EQUAL, value: "repo:${owner}/${repo} issue:${issueNumber}"}}) {
                      nodes {
                        id
                        fieldValues(first: 20) {
                          nodes {
                            ... on ProjectV2ItemFieldSingleSelectValue {
                              name
                              field {
                                ... on ProjectV2SingleSelectField {
                                  name
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }`;
              
              // Buscar la issue en el proyecto
              const issueInProject = await github.graphql(itemQuery, {
                projectId: projectId,
                issueNumber: parseInt(issue.number),
                owner: context.repo.owner,
                repo: context.repo.repo
              });
              
              // Verificar si la issue está en el proyecto
              const items = issueInProject.node.items.nodes;
              if (items.length === 0) {
                console.log(`Issue #${issue.number} not found in project`);
                return JSON.stringify({status: null, projectId: projectId, statusFieldId: statusField.id});
              }
              
              // Obtener el estado actual
              const itemId = items[0].id;
              let currentStatus = null;
              
              items[0].fieldValues.nodes.forEach(fieldValue => {
                if (fieldValue.field && fieldValue.field.name === statusFieldName) {
                  currentStatus = fieldValue.name;
                }
              });
              
              console.log(`Issue #${issue.number} status in project: ${currentStatus || "Not set"}`);
              
              return JSON.stringify({
                status: currentStatus,
                projectId: projectId,
                itemId: itemId,
                statusFieldId: statusField.id,
                statusOptions: statusField.options || []
              });
            } catch (error) {
              console.error(`Error querying project: ${error.message}`);
              return JSON.stringify({status: null});
            }
        env:
          ISSUE_DATA: ${{ steps.issue_data.outputs.result }}

      - name: Create branch for issue (In Progress)
        if: |
          ${{ fromJson(steps.issue_data.outputs.result).issue }} && 
          (${{ fromJson(steps.project_status.outputs.result).status == env.IN_PROGRESS_STATUS }} || 
           ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'branch_creation' }})
        run: |
          # Parsear datos desde los pasos anteriores
          ISSUE_DATA='${{ steps.issue_data.outputs.result }}'
          ISSUE_NUMBER=$(echo $ISSUE_DATA | jq -r '.issue.number')
          ISSUE_TITLE=$(echo $ISSUE_DATA | jq -r '.issue.title')
          LABELS=$(echo $ISSUE_DATA | jq -r '.issue.labels | join(" ")')
          
          # Sanitizar título para nombre de rama
          SANITIZED_TITLE=$(echo "$ISSUE_TITLE" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-zA-Z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-//' | sed 's/-$//')
          
          # Tipo de rama predeterminado
          BRANCH_TYPE="feature"
          
          # Determinar tipo de rama basado en etiquetas
          if echo "$LABELS" | grep -q "documentation"; then
            BRANCH_TYPE="documentation"
          elif echo "$LABELS" | grep -q "bug" || echo "$LABELS" | grep -q "hotfix"; then
            BRANCH_TYPE="hotfix"
          fi
          
          # Crear y subir rama
          BRANCH_NAME="${BRANCH_TYPE}/${ISSUE_NUMBER}-${SANITIZED_TITLE}"
          
          # Verificar si la rama ya existe
          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
            echo "Branch $BRANCH_NAME already exists"
          else
            git config user.name "GitHub Actions"
            git config user.email "actions@github.com"
            git checkout -b "$BRANCH_NAME" 
            git push origin "$BRANCH_NAME"
            
            echo "Created branch: $BRANCH_NAME"
            
            # Añadir comentario a la issue con info de la rama
            gh issue comment "$ISSUE_NUMBER" --body "🔨 Branch \`$BRANCH_NAME\` was automatically created for this issue."
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}

      - name: Create PR for issue (In Review)
        if: |
          ${{ fromJson(steps.issue_data.outputs.result).issue }} && 
          (${{ fromJson(steps.project_status.outputs.result).status == env.IN_REVIEW_STATUS }} || 
           ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'pr_creation' }})
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.PAT_TOKEN }}
          script: |
            const issueData = JSON.parse(process.env.ISSUE_DATA);
            const issue = issueData.issue;
            const issueNumber = issue.number;
            const issueTitle = issue.title;
            
            // Listar ramas que podrían estar relacionadas con esta issue
            const { data: branches } = await github.rest.repos.listBranches({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            
            // Buscar rama con el número de issue en el nombre
            const issueBranch = branches.find(branch => branch.name.includes(`/${issueNumber}-`));
            
            if (!issueBranch) {
              console.log(`No branch found for issue #${issueNumber}`);
              return;
            }
            
            // Verificar si ya existe un PR para esta rama
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${issueBranch.name}`,
              state: 'open'
            });
            
            if (prs.length > 0) {
              console.log(`PR already exists for branch ${issueBranch.name}`);
              return;
            }
            
            // Crear PR
            try {
              const { data: pr } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: issueTitle,
                body: `Resolves #${issueNumber}`,
                head: issueBranch.name,
                base: process.env.BASE_BRANCH
              });
              
              console.log(`Created PR #${pr.number} for issue #${issueNumber}`);
              
              // Añadir comentario en la issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: `📝 Pull request [#${pr.number}](${pr.html_url}) has been created for this issue.`
              });
            } catch (error) {
              console.error(`Error creating PR: ${error.message}`);
            }
        env:
          ISSUE_DATA: ${{ steps.issue_data.outputs.result }}

      - name: Move issue to Done when PR is merged
        if: |
          github.event_name == 'pull_request' && 
          github.event.pull_request.merged == true && 
          ${{ fromJson(steps.issue_data.outputs.result).issue }}
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.PAT_TOKEN }}
          script: |
            const issueData = JSON.parse(process.env.ISSUE_DATA);
            const issue = issueData.issue;
            const projectData = JSON.parse(process.env.PROJECT_DATA);
            
            if (!projectData.itemId || !projectData.statusFieldId) {
              console.log(`Issue #${issue.number} not properly configured in project`);
              return;
            }
            
            // Buscar la opción "Done" entre las opciones de estado
            const doneStatusOption = projectData.statusOptions.find(option => option.name === process.env.DONE_STATUS);
            if (!doneStatusOption) {
              console.log(`"${process.env.DONE_STATUS}" status option not found in project`);
              return;
            }
            
            // Cambiar el estado a "Done"
            const updateMutation = `
            mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
              updateProjectV2ItemFieldValue(input: {
                projectId: $projectId,
                itemId: $itemId,
                fieldId: $fieldId,
                value: { singleSelectOptionId: $optionId }
              }) {
                projectV2Item {
                  id
                }
              }
            }`;
            
            try {
              await github.graphql(updateMutation, {
                projectId: projectData.projectId,
                itemId: projectData.itemId,
                fieldId: projectData.statusFieldId,
                optionId: doneStatusOption.id
              });
              
              console.log(`Moved issue #${issue.number} to ${process.env.DONE_STATUS} status`);
              
              // Añadir comentario en la issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `✅ This issue has been automatically moved to \`${process.env.DONE_STATUS}\` after the PR was merged.`
              });
            } catch (error) {
              console.error(`Error updating project item: ${error.message}`);
            }
        env:
          ISSUE_DATA: ${{ steps.issue_data.outputs.result }}
          PROJECT_DATA: ${{ steps.project_status.outputs.result }}